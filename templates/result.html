{% extends 'base.html' %}
{% block head %}{% endblock %}
{% block body %}
<h1>Style Errors</h1>
<p id='styleErrors'>
Line 7: Lines can not exceede 80 characters.<br>
Line 34: Lines can not exceede 80 characters.<br>
Line 69: Inconsistent operator spacing.<br>
Line 75: Inconsistent operator spacing.<br>
Line 86: Inconsistent operator spacing.<br>
Line 155: Lines can not exceede 80 characters.<br>
Line 156: Lines can not exceede 80 characters.<br>
Line 158: Lines can not exceede 80 characters.<br>
Line 169: Lines can not exceede 80 characters.<br>
Line 171: Lines can not exceede 80 characters.<br>
Line 177: Inconsistent operator spacing.<br>
Line 238: Lines can not exceede 80 characters.<br>
Line 258: Inconsistent operator spacing.<br>
Line 293: Lines can not exceede 80 characters.<br>
Line 318: Lines can not exceede 80 characters.<br>
Line 326: Lines can not exceede 80 characters.<br>
Line 356: Lines can not exceede 80 characters.<br>
Line 402: Lines can not exceede 80 characters.<br>
Line 444: Lines can not exceede 80 characters.<br>
Line 454: Inconsistent operator spacing.<br>
Line 467: Lines can not exceede 80 characters.<br>
Line 484: Lines can not exceede 80 characters.<br>
Line 492: Magic numbers should be constant.<br>
Line 493: Magic numbers should be constant.<br>
Line 494: Inconsistent operator spacing.<br>
Line 495: Inconsistent operator spacing.<br>
Line 559: Inconsistent operator spacing.<br>
Line 576: Lines can not exceede 80 characters.<br>
</p>
<h1>Code</h1>
<p id='code'>
1 //  CodeCamp.java - CS314 Assignment 1<br>
2 <br>
3 /*  Student information for assignment:<br>
4  *<br>
5  *  replace <NAME> with your name.<br>
6  *<br>
<span class='tooltip'>7  *  On my honor, Rodrigo Okamoto Corbellini Pereira, this programming assignment is my own work<span class='tooltiptext'>Lines can not exceede 80 characters.</span></span><br>
8  *  and I have not provided this code to any other student.<br>
9  *<br>
10  *  Name: Rodrigo Okamoto Corbellini Pereira<br>
11  *  email address: rodrigoocp@utexas.edu<br>
12  *  UTEID: ro7929<br>
13  *  Section 5 digit ID: 50915<br>
14  *  Grader name: Irena<br>
15  *  Number of slip days used on this assignment: 0<br>
16  */<br>
17 <br>
18 import java.util.Random;<br>
19 <br>
20 public class CodeCamp {<br>
21 <br>
22     /**<br>
23      * Determine the Hamming distance between two arrays of ints.<br>
24      * Neither the parameter <tt>aData</tt> or<br>
25      * <tt>bData</tt> are altered as a result of this method.<br><br>
26      * @param aData != null, aData.length == aData.length<br>
27      * @param bData != null<br>
28      * @return the Hamming Distance between the two arrays of ints.<br>
29      */<br>
30     public static int hammingDistance(int[] aData, int[] bData) {<br>
31         // check preconditions<br>
32         if (aData == null || bData == null || aData.length != bData.length) {<br>
33             throw new IllegalArgumentException("Violation of precondition: " +<br>
<span class='tooltip'>34                     "hammingDistance. neither parameter may equal null, arrays" +<span class='tooltiptext'>Lines can not exceede 80 characters.</span></span><br>
35                     " must be equal length.");<br>
36         }<br>
37 <br>
38         int hammingDistanceCount = 0;<br>
39         // go through both arrays and if the values at the same index<br>
40         // are different, then add to count<br>
41         for(int i = 0; i < aData.length ; i++){<br>
42 <br>
43             if(aData[i] != bData[i]){<br>
44                 hammingDistanceCount++;<br>
45             }<br>
46 <br>
47         }<br>
48 <br>
49         return hammingDistanceCount;<br>
50     }<br>
51 <br>
52 <br>
53     /**<br>
54      * Sorts a given array from least to greatest<br>
55      *<br>
56      * @param array the array to sort<br>
57      * @return a sorted array from least to greatest<br>
58      *<br>
59     */<br>
60     private static int[] sort(int[] array){<br>
61         // use a string array so that it is all null by default<br>
62         String[] newArray = new String[array.length + 1];<br>
63 <br>
64         // go through array<br>
65         for(int arrayIndex = 0; arrayIndex<array.length; arrayIndex++){<br>
66 <br>
67             // compare all items in new array with currently selected item<br>
68             // from the original array<br>
<span class='tooltip'>69             for(int newArrayIndex = newArray.length-1; newArrayIndex >= 0;<span class='tooltiptext'>Inconsistent operator spacing.</span></span><br>
70                      newArrayIndex--){<br>
71 <br>
72                 if(newArrayIndex == newArray.length - 1){<br>
73 <br>
74                     // if last index then add to newArray<br>
<span class='tooltip'>75                     newArray[newArrayIndex] = ""+array[arrayIndex];<span class='tooltiptext'>Inconsistent operator spacing.</span></span><br>
76 <br>
77                 }else{<br>
78 <br>
79                     // if next spot is less than or empty (== null)<br>
80                     // then place currently selected item in new array<br>
81                     if(newArray[newArrayIndex] == null<br>
82                             || array[arrayIndex]<br>
83                             < Integer.parseInt(newArray[newArrayIndex])){<br>
84 <br>
85                         newArray[newArrayIndex + 1] = newArray[newArrayIndex];<br>
<span class='tooltip'>86                         newArray[newArrayIndex] = ""+array[arrayIndex];<span class='tooltiptext'>Inconsistent operator spacing.</span></span><br>
87                     }<br>
88 <br>
89                 }<br>
90 <br>
91 <br>
92             }<br>
93 <br>
94         }<br>
95 <br>
96         // convert string array back to int array<br>
97         int[]returnArr = new int[array.length];<br>
98         for(int i = 0; i < array.length; i++){<br>
99             returnArr[i] = Integer.parseInt(newArray[i]);<br>
100         }<br>
101 <br>
102         return returnArr;<br>
103 <br>
104     }<br>
105 <br>
106     /**<br>
107      * Determine if one array of ints is a permutation of another.<br>
108      * Neither the parameter <tt>aData</tt> or<br>
109      * the parameter <tt>bData</tt> are altered as a result of this method.<br><br>
110      * @param aData != null<br>
111      * @param bData != null<br>
112      * @return <tt>true</tt> if aData is a permutation of bData,<br>
113      * <tt>false</tt> otherwise<br>
114      *<br>
115      */<br>
116     public static boolean isPermutation(int[] aData, int[] bData) {<br>
117         // check preconditions<br>
118         if (aData == null || bData == null) {<br>
119             throw new IllegalArgumentException("Violation of precondition: " +<br>
120                     "isPermutation. neither parameter may equal null.");<br>
121         }<br>
122 <br>
123         // Both arrays must be the same length before checking if its a<br>
124         // permutation<br>
125         if(aData.length == bData.length){<br>
126 <br>
127             // sort both arrays<br>
128             int[] sortedAData = sort(aData);<br>
129             int[] sortedBData = sort(bData);<br>
130 <br>
131             // check to see if all numbers match<br>
132             for(int i = 0; i < aData.length; i++){<br>
133 <br>
134                 if(sortedAData[i] != sortedBData[i]){<br>
135                     return false;<br>
136                 }<br>
137 <br>
138             }<br>
139 <br>
140         }else{<br>
141             // not a permutation if not the same length<br>
142             return false;<br>
143         }<br>
144 <br>
145         // if no differences were found in sorted arrays, then its a permutation<br>
146         return true;<br>
147     }<br>
148 <br>
149 <br>
150     /**<br>
151      * Determine the index of the String that<br>
152      * has the largest number of vowels.<br>
153      * Vowels are defined as <tt>'A', 'a', 'E', 'e', 'I', 'i', 'O', 'o',<br>
154      * 'U', and 'u'</tt>.<br>
<span class='tooltip'>155      * The parameter <tt>arrayOfStrings</tt> is not altered as a result of this method.<span class='tooltiptext'>Lines can not exceede 80 characters.</span></span><br>
<span class='tooltip'>156      * <p>pre: <tt>arrayOfStrings != null</tt>, <tt>arrayOfStrings.length > 0</tt>,<span class='tooltiptext'>Lines can not exceede 80 characters.</span></span><br>
157      * there is an least 1 non null element in arrayOfStrings.<br>
<span class='tooltip'>158      * <p>post: return the index of the non-null element in arrayOfStrings that has the<span class='tooltiptext'>Lines can not exceede 80 characters.</span></span><br>
159      * largest number of characters that are vowels.<br>
160      * If there is a tie return the index closest to zero.<br>
161      * The empty String, "", has zero vowels.<br>
162      * It is possible for the maximum number of vowels to be 0.<br><br>
163      * @param arrayOfStrings the array to check<br>
164      * @return the index of the non-null element in arrayOfStrings that has<br>
165      * the largest number of vowels.<br>
166      */<br>
167     public static int mostVowels(String[] arrayOfStrings) {<br>
168         // check preconditions<br>
<span class='tooltip'>169         if (arrayOfStrings == null || arrayOfStrings.length == 0 || !atLeastOneNonNull(arrayOfStrings)) {<span class='tooltiptext'>Lines can not exceede 80 characters.</span></span><br>
170             throw new IllegalArgumentException("Violation of precondition: " +<br>
<span class='tooltip'>171                     "mostVowels. parameter may not equal null and must contain " +<span class='tooltiptext'>Lines can not exceede 80 characters.</span></span><br>
172                     "at least one none null value.");<br>
173         }<br>
174 <br>
175         String vowels = "aeiou";<br>
176         // last index of array since the loop starts from the end of array<br>
<span class='tooltip'>177         int indexOfMostVowels = arrayOfStrings.length-1;<span class='tooltiptext'>Inconsistent operator spacing.</span></span><br>
178         int countOfVowelsInMostVowels = 0;<br>
179 <br>
180         // go through all of the strings int the array<br>
181         // Start from end of array so you can settle tie with string<br>
182         // closest to index 0<br>
183         for(int i = arrayOfStrings.length - 1; i >=0; i--){<br>
184 <br>
185             // make sure the string isnt null<br>
186             if(arrayOfStrings[i] != null){<br>
187 <br>
188                 // turn the string into an all lowercase array of strings<br>
189                 // so that you can check if each character is a vowel<br>
190                 String[]str = arrayOfStrings[i].toLowerCase().split("");<br>
191                 int countOfVowels = 0;<br>
192 <br>
193                 // count vowels in currently selected string<br>
194                 for(String x: str){<br>
195 <br>
196                     // must ignore empty string and see if the character<br>
197                     // is vowel before counting<br>
198                     if(!x.equals("") && vowels.contains(x)){<br>
199                         countOfVowels++;<br>
200                     }<br>
201 <br>
202                 }<br>
203 <br>
204                 // if this string has more vowels than previous<br>
205                 // then set it's index as the indexOfMostVowels<br>
206                 // and replace highest vowel count to current count<br>
207                 if(countOfVowels >= countOfVowelsInMostVowels){<br>
208                     indexOfMostVowels = i;<br>
209                     countOfVowelsInMostVowels = countOfVowels;<br>
210                 }<br>
211 <br>
212             }<br>
213 <br>
214 <br>
215         }<br>
216 <br>
217         return indexOfMostVowels;<br>
218     }<br>
219 <br>
220 <br>
221 <br>
222     /**<br>
223      * Perform an experiment simulating the birthday problem.<br>
224      * Pick random birthdays for the given number of people.<br>
225      * Return the number of pairs of people that share the<br>
226      * same birthday.<br><br>
227      * @param numPeople The number of people in the experiment.<br>
228      * This value must be > 0<br>
229      * @param numDaysInYear The number of days in the year for this experiement.<br>
230      * This value must be > 0<br>
231      * @return The number of pairs of people that share a birthday<br>
232      * after running the simulation.<br>
233      */<br>
234     public static int sharedBirthdays(int numPeople, int numDaysInYear) {<br>
235         // check preconditions<br>
236         if (numPeople <= 0 || numDaysInYear <= 0) {<br>
237             throw new IllegalArgumentException("Violation of precondition: " +<br>
<span class='tooltip'>238                     "sharedBirthdays. both parameters must be greater than 0. " +<span class='tooltiptext'>Lines can not exceede 80 characters.</span></span><br>
239                     "numPeople: " + numPeople +<br>
240                     ", numDaysInYear: " + numDaysInYear);<br>
241         }<br>
242 <br>
243         int[] birthdays = new int[numPeople];<br>
244         int numberOfPairs = 0;<br>
245 <br>
246         // generate random birthdays<br>
247         for(int i = 0; i<numPeople; i++){<br>
248             Random r = new Random();<br>
249             birthdays[i] = r.nextInt(numDaysInYear);<br>
250 <br>
251         }<br>
252 <br>
253         // go through list of birthdays<br>
254         for(int i = 0; i < birthdays.length; i++){<br>
255 <br>
256             // compare to every birthday except itself and the ones before it<br>
257             // because the ones before it have already been compared<br>
<span class='tooltip'>258             for(int x = i+1; x < birthdays.length; x++){<span class='tooltiptext'>Inconsistent operator spacing.</span></span><br>
259                 if(birthdays[i] == birthdays[x]){<br>
260                     numberOfPairs++;<br>
261                 }<br>
262             }<br>
263 <br>
264         }<br>
265 <br>
266         return numberOfPairs;<br>
267     }<br>
268 <br>
269 <br>
270 <br>
271     /**<br>
272      * Determine if the chess board represented by board is a safe set up.<br>
273      * <p>pre: board != null, board.length > 0, board is a square matrix.<br>
274      * (In other words all rows in board have board.length columns.),<br>
275      * all elements of board == 'q' or '.'. 'q's represent queens, '.'s<br>
276      * represent open spaces.<br><br>
277      * <p>post: return true if the configuration of board is safe,<br>
278      * that is no queen can attack any other queen on the board.<br>
279      * false otherwise.<br>
280      * the parameter <tt>board</tt> is not altered as a result of<br>
281      * this method.<br><br>
282      * @param board the chessboard<br>
283      * @return true if the configuration of board is safe,<br>
284      * that is no queen can attack any other queen on the board.<br>
285      * false otherwise.<br>
286      */<br>
287     public static boolean queensAreSafe(char[][] board) {<br>
288         char[] validChars = {'q', '.'};<br>
289         // check preconditions<br>
290         if (board == null || board.length == 0 || !isSquare(board)<br>
291                 || !onlyContains(board, validChars)) {<br>
292             throw new IllegalArgumentException("Violation of precondition: " +<br>
<span class='tooltip'>293                     "queensAreSafe. The board may not be null, must be square, " +<span class='tooltiptext'>Lines can not exceede 80 characters.</span></span><br>
294                     "and may only contain 'q's and '.'s");<br>
295         }<br>
296 <br>
297         char queen = validChars[0];  // 'q' stands for queen on the board<br>
298         for(int row = 0; row < board.length; row++){<br>
299 <br>
300             for(int column = 0; column < board.length; column++){<br>
301                 // find queen in matrix<br>
302                 if(board[row][column] == queen){<br>
303 <br>
304                     for(int i = 0; i < board.length; i++){<br>
305                         // check horizontal for queen<br>
306                         if(i != column && board[row][i] == queen){<br>
307                             return false;<br>
308                         }<br>
309 <br>
310                         // check vertical for queen<br>
311                         if(i != row && board[i][column] == queen){<br>
312 <br>
313                             return false;<br>
314                         }<br>
315 <br>
316                         // check diagonal 1(\) for queen<br>
317                         int columnDiagonal1 = column - (row - i);<br>
<span class='tooltip'>318                         if(columnDiagonal1 >= 0 && columnDiagonal1 < board.length){<span class='tooltiptext'>Lines can not exceede 80 characters.</span></span><br>
319                             if(i != row && board[i][columnDiagonal1] == queen){<br>
320                                 return false;<br>
321                             }<br>
322                         }<br>
323 <br>
324                         // check diagonal 2(/) for queen<br>
325                         int columnDiagonal2 = column + (row - i);<br>
<span class='tooltip'>326                         if(columnDiagonal2 < board.length && columnDiagonal2 >= 0){<span class='tooltiptext'>Lines can not exceede 80 characters.</span></span><br>
327                             if(i != row && board[i][columnDiagonal2] == queen){<br>
328                                 return false;<br>
329                             }<br>
330                         }<br>
331 <br>
332                     }<br>
333 <br>
334 <br>
335                 }<br>
336             }<br>
337         }<br>
338 <br>
339         // passed all directional tests for all queens on the board<br>
340         // so the board is safe<br>
341         return true;<br>
342     }<br>
343 <br>
344     /**<br>
345      * Given a 2D array and a starting point (row,column) it returns<br>
346      * the value of the most valuable contiguous sub rectangle from<br>
347      * that starting point<br>
348      *<br>
349      * @param city The 2D array of ints representing the value of<br>
350      * each block in a portion of a city.<br>
351      * @param row the row of the starting point in the city array<br>
352      * @param column the column of the starting point in the city array<br>
353      * @return the value of the most valuable contiguous sub rectangle<br>
354      * in the city array from the given starting point with row and column<br>
355      */<br>
<span class='tooltip'>356     private static int getMostValueFromStartingPoint(int[][]city, int row, int column){<span class='tooltiptext'>Lines can not exceede 80 characters.</span></span><br>
357         int highestValue = city[row][column];<br>
358 <br>
359         // runs through all rows from starting row and onwards<br>
360         for(int r = row; r < city.length; r++){<br>
361             // keeps count of value of current rectangle<br>
362             int sum = 0;<br>
363 <br>
364             // runs through all columns from starting column and onwards<br>
365             for(int c = column; c < city[r].length; c++){<br>
366                 // adds values from previous columns<br>
367                 for(int currentRow = r; currentRow >= row; currentRow--){<br>
368                     sum += city[currentRow][c];<br>
369                 }<br>
370                 // if current rectangle is larger than previously<br>
371                 // largest rectangle then replace<br>
372                 // highest value with new rectangle value<br>
373                 if(sum > highestValue){<br>
374                     highestValue = sum;<br>
375                 }<br>
376 <br>
377             }<br>
378 <br>
379         }<br>
380 <br>
381         return highestValue;<br>
382     }<br>
383 <br>
384     /**<br>
385      * Given a 2D array of ints return the value of the<br>
386      * most valuable contiguous sub rectangle in the 2D array.<br>
387      * The sub rectangle must be at least 1 by 1.<br>
388      * <p>pre: <tt>mat != null, mat.length > 0, mat[0].length > 0,<br>
389      * mat</tt> is a rectangular matrix.<br>
390      * <p>post: return the value of the most valuable contiguous sub rectangle<br>
391      * in <tt>city</tt>.<br><br>
392      * @param city The 2D array of ints representing the value of<br>
393      * each block in a portion of a city.<br>
394      * @return return the value of the most valuable contiguous sub rectangle<br>
395      * in <tt>city</tt>.<br>
396      */<br>
397     public static int getValueOfMostValuablePlot(int[][] city) {<br>
398         // check preconditions<br>
399         if (city == null || city.length == 0 || city[0].length == 0<br>
400                 || !isRectangular(city) ) {<br>
401             throw new IllegalArgumentException("Violation of precondition: " +<br>
<span class='tooltip'>402                     "getValueOfMostValuablePlot. The parameter may not be null," +<span class='tooltiptext'>Lines can not exceede 80 characters.</span></span><br>
403                     " must value at least one row and at least" +<br>
404                     " one column, and must be rectangular.");<br>
405         }<br>
406 <br>
407         int highestValue = city[0][0];<br>
408 <br>
409         for(int row = 0; row<city.length; row++){<br>
410 <br>
411             for(int column = 0; column < city[row].length; column++){<br>
412                 // finds rectangle with highest value from this point<br>
413                 int maxValFromThisPoint =<br>
414                         getMostValueFromStartingPoint(city, row, column);<br>
415                 // if this new highest value exceeds previous highest value,<br>
416                 // then it replaces it<br>
417                 if(maxValFromThisPoint > highestValue){<br>
418                     highestValue = maxValFromThisPoint;<br>
419                 }<br>
420             }<br>
421 <br>
422         }<br>
423 <br>
424         // returns highest possible value out of the 2D array<br>
425         // out of all starting points<br>
426         return highestValue;<br>
427     }<br>
428 <br>
429 <br>
430     // !!!!! ***** !!!!! ***** !!!!! ****** !!!!! ****** !!!!! ****** !!!!!!<br>
431     // CS314 STUDENTS: Put your birthday problem experiment code here:<br>
432 <br>
433     /**<br>
434      * perform birthday experiment as many times as you want<br>
435      * works with sharedBirthdays method<br>
436      * returns average number of pairs that occur<br>
437      *<br>
438      * @param numOfExperiments the number of experiments that you want to run<br>
439      * @param numPeople the number of people to be used in the birthday problem<br>
440      * @param daysPerYear the number of days in a year to be<br>
441      * used in the birthday problem<br>
442      * @return the average number of pairs out of all of the experiments<br>
443      */<br>
<span class='tooltip'>444     public static double averageNumberOfPairsExperiment(int numOfExperiments, int numPeople, int daysPerYear){<span class='tooltiptext'>Lines can not exceede 80 characters.</span></span><br>
445         // keeps count of the sum of all the results<br>
446         double totalSumOfPairs = 0;<br>
447 <br>
448         // performs expriments and adds results to totalSumOfPairs<br>
449         for(int i = 0; i < numOfExperiments; i++){<br>
450             totalSumOfPairs += sharedBirthdays(numPeople, daysPerYear);<br>
451         }<br>
452 <br>
453         // returns the average number of pairs<br>
<span class='tooltip'>454         return totalSumOfPairs/numOfExperiments;<span class='tooltiptext'>Inconsistent operator spacing.</span></span><br>
455     }<br>
456 <br>
457     /**<br>
458      * performs birthday experiment and returns the number of experiments<br>
459      * that have at least 1 shared birthday<br>
460      *<br>
461      * @param numOfExperiments the number of experiments you want to run<br>
462      * @param numPeople the number of people to be used in the birthday problem<br>
463      * @param daysInYear the number of days in a year to be used<br>
464      * in the birthday problem<br>
465      * @return the number of experiments that had at least one pair<br>
466      */<br>
<span class='tooltip'>467     public static int countOfExperimentsWithAPair(int numOfExperiments, int numPeople, int daysInYear){<span class='tooltiptext'>Lines can not exceede 80 characters.</span></span><br>
468         // keeps count of experiments that have atleast one pair<br>
469         int countOfExperiments = 0;<br>
470 <br>
471         // runs experiments<br>
472         for(int i = 0; i < numOfExperiments; i++){<br>
473             // adds to counter if experiment has a pair<br>
474             if(sharedBirthdays(numPeople, daysInYear) >= 1){<br>
475                 countOfExperiments++;<br>
476             }<br>
477         }<br>
478 <br>
479         return countOfExperiments;<br>
480 <br>
481     }<br>
482 <br>
483     /**<br>
<span class='tooltip'>484      * Performs the second experiment for the birthday problem and draws the table<span class='tooltiptext'>Lines can not exceede 80 characters.</span></span><br>
485      *<br>
486      * @param minRange the minimum number of people (inclusive)<br>
487      * @param maxRange the maximum number of people (inclusive)<br>
488      */<br>
489     public static void runBirthdayExperiment2(int minRange, int maxRange){<br>
490 <br>
491         for(int i = minRange; i <= maxRange; i++){<br>
<span class='tooltip'>492             int count = countOfExperimentsWithAPair(50000, i, 365);<span class='tooltiptext'>Magic numbers should be constant.</span></span><br>
<span class='tooltip'>493             double percentage = (count/50000.)*100;<span class='tooltiptext'>Magic numbers should be constant.</span></span><br>
<span class='tooltip'>494             System.out.print("Num people: "+i+", number of experiments with one or more shared birthday: "+count+", percentage: ");<span class='tooltiptext'>Inconsistent operator spacing.</span></span><br>
<span class='tooltip'>495             System.out.printf("%.2f",percentage);<span class='tooltiptext'>Inconsistent operator spacing.</span></span><br>
496             System.out.println();<br>
497         }<br>
498     }<br>
499 <br>
500     /*<br>
501      * pre: arrayOfStrings != null<br>
502      * post: return true if at least one element in arrayOfStrings is<br>
503      * not null, otherwise return false.<br>
504      */<br>
505     private static boolean atLeastOneNonNull(String[] arrayOfStrings) {<br>
506         // check precondition<br>
507         if (arrayOfStrings == null) {<br>
508             throw new IllegalArgumentException("Violation of precondition: " +<br>
509                     "atLeastOneNonNull. parameter may not equal null.");<br>
510         }<br>
511         boolean foundNonNull = false;<br>
512         int i = 0;<br>
513         while( !foundNonNull && i < arrayOfStrings.length ) {<br>
514             foundNonNull = arrayOfStrings[i] != null;<br>
515             i++;<br>
516         }<br>
517         return foundNonNull;<br>
518     }<br>
519 <br>
520 <br>
521     /*<br>
522      * pre: mat != null<br>
523      * post: return true if mat is a square matrix, false otherwise<br>
524      */<br>
525     private static boolean isSquare(char[][] mat) {<br>
526         if (mat == null) {<br>
527             throw new IllegalArgumentException("Violation of precondition: " +<br>
528                     "isSquare. Parameter may not be null.");<br>
529         }<br>
530         final int numRows = mat.length;<br>
531         int row = 0;<br>
532         boolean isSquare = true;<br>
533         while (isSquare && row < numRows) {<br>
534             isSquare = ( mat[row] != null) && (mat[row].length == numRows);<br>
535             row++;<br>
536         }<br>
537         return isSquare;<br>
538     }<br>
539 <br>
540 <br>
541     /*<br>
542      * pre: mat != null, valid != null<br>
543      * post: return true if all elements in mat are one of the<br>
544      * characters in valid<br>
545      */<br>
546     private static boolean onlyContains(char[][] mat, char[] valid) {<br>
547         // check preconditions<br>
548         if (mat == null || valid == null) {<br>
549             throw new IllegalArgumentException("Violation of precondition: " +<br>
550                     "onlyContains. Parameters may not be null.");<br>
551         }<br>
552         String validChars = new String(valid);<br>
553         int row = 0;<br>
554         boolean onlyContainsValidChars = true;<br>
555         while (onlyContainsValidChars && row < mat.length) {<br>
556             int col = 0;<br>
557             while(onlyContainsValidChars && col < mat[row].length) {<br>
558                 int indexOfChar = validChars.indexOf(mat[row][col]);<br>
<span class='tooltip'>559                 onlyContainsValidChars = indexOfChar != -1;<span class='tooltiptext'>Inconsistent operator spacing.</span></span><br>
560                 col++;<br>
561             }<br>
562             row++;<br>
563         }<br>
564         return onlyContainsValidChars;<br>
565     }<br>
566 <br>
567 <br>
568     /*<br>
569      * pre: mat != null, mat.length > 0<br>
570      * post: return true if mat is rectangular<br>
571      */<br>
572     private static boolean isRectangular(int[][] mat) {<br>
573         // check preconditions<br>
574         if (mat == null || mat.length == 0) {<br>
575             throw new IllegalArgumentException("Violation of precondition: " +<br>
<span class='tooltip'>576                     "isRectangular. Parameter may not be null and must contain" +<span class='tooltiptext'>Lines can not exceede 80 characters.</span></span><br>
577                     " at least one row.");<br>
578         }<br>
579         boolean correct = mat[0] != null;<br>
580         int row = 0;<br>
581         while(correct && row < mat.length) {<br>
582             correct = (mat[row] != null)<br>
583                     && (mat[row].length == mat[0].length);<br>
584             row++;<br>
585         }<br>
586         return correct;<br>
587     }<br>
588 <br>
589     // make constructor private so no instances of CodeCamp can not be created<br>
590     private CodeCamp() {<br>
591 <br>
592     }<br>
593 }<br>
</p>
<form action="/back" method="POST" enctype="multipart/form-data"><button>back</button></form>
{% endblock %}
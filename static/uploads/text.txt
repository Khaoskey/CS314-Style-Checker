//  CodeCamp.java - CS314 Assignment 1

/*  Student information for assignment:
 * 
 *  replace <NAME> with your name.
 *
 *  On my honor, Rodrigo Okamoto Corbellini Pereira, this programming assignment is my own work
 *  and I have not provided this code to any other student.
 *
 *  Name: Rodrigo Okamoto Corbellini Pereira
 *  email address: rodrigoocp@utexas.edu
 *  UTEID: ro7929
 *  Section 5 digit ID: 50915
 *  Grader name: Irena
 *  Number of slip days used on this assignment: 0
 */

import java.util.Random;

public class CodeCamp {

    /**
     * Determine the Hamming distance between two arrays of ints. 
     * Neither the parameter <tt>aData</tt> or
     * <tt>bData</tt> are altered as a result of this method.<br>
     * @param aData != null, aData.length == aData.length
     * @param bData != null
     * @return the Hamming Distance between the two arrays of ints.
     */    
    public static int hammingDistance(int[] aData, int[] bData) {
        // check preconditions
        if (aData == null || bData == null || aData.length != bData.length) { 
            throw new IllegalArgumentException("Violation of precondition: " +
                    "hammingDistance. neither parameter may equal null, arrays" +
                    " must be equal length.");
        }

        int hammingDistanceCount = 0;
        // go through both arrays and if the values at the same index 
        // are different, then add to count
        for(int i = 0; i < aData.length ; i++){
            
            if(aData[i] != bData[i]){
                hammingDistanceCount++; 
            }

        }

        return hammingDistanceCount;
    }


    /**
     * Sorts a given array from least to greatest
     * 
     * @param array the array to sort
     * @return a sorted array from least to greatest
     * 
    */  
    private static int[] sort(int[] array){
        // use a string array so that it is all null by default
        String[] newArray = new String[array.length + 1];
        
        // go through array
        for(int arrayIndex = 0; arrayIndex<array.length; arrayIndex++){

            // compare all items in new array with currently selected item 
            // from the original array
            for(int newArrayIndex = newArray.length-1; newArrayIndex >= 0;
                     newArrayIndex--){

                if(newArrayIndex == newArray.length - 1){
                    
                    // if last index then add to newArray
                    newArray[newArrayIndex] = ""+array[arrayIndex];

                }else{

                    // if next spot is less than or empty (== null)
                    // then place currently selected item in new array
                    if(newArray[newArrayIndex] == null 
                            || array[arrayIndex] 
                            < Integer.parseInt(newArray[newArrayIndex])){

                        newArray[newArrayIndex + 1] = newArray[newArrayIndex];
                        newArray[newArrayIndex] = ""+array[arrayIndex];
                    }

                }
                

            }

        }

        // convert string array back to int array
        int[]returnArr = new int[array.length];
        for(int i = 0; i < array.length; i++){
            returnArr[i] = Integer.parseInt(newArray[i]);
        }

        return returnArr;
        
    }

    /**
     * Determine if one array of ints is a permutation of another.
     * Neither the parameter <tt>aData</tt> or 
     * the parameter <tt>bData</tt> are altered as a result of this method.<br>
     * @param aData != null
     * @param bData != null
     * @return <tt>true</tt> if aData is a permutation of bData, 
     * <tt>false</tt> otherwise
     * 
     */
    public static boolean isPermutation(int[] aData, int[] bData) {
        // check preconditions
        if (aData == null || bData == null) {
            throw new IllegalArgumentException("Violation of precondition: " +
                    "isPermutation. neither parameter may equal null.");
        }
        
        // Both arrays must be the same length before checking if its a 
        // permutation
        if(aData.length == bData.length){

            // sort both arrays
            int[] sortedAData = sort(aData);
            int[] sortedBData = sort(bData);
            
            // check to see if all numbers match 
            for(int i = 0; i < aData.length; i++){

                if(sortedAData[i] != sortedBData[i]){
                    return false;
                }

            }

        }else{
            // not a permutation if not the same length
            return false;
        }
        
        // if no differences were found in sorted arrays, then its a permutation
        return true; 
    }


    /**
     * Determine the index of the String that 
     * has the largest number of vowels. 
     * Vowels are defined as <tt>'A', 'a', 'E', 'e', 'I', 'i', 'O', 'o', 
     * 'U', and 'u'</tt>.
     * The parameter <tt>arrayOfStrings</tt> is not altered as a result of this method.
     * <p>pre: <tt>arrayOfStrings != null</tt>, <tt>arrayOfStrings.length > 0</tt>, 
     * there is an least 1 non null element in arrayOfStrings.
     * <p>post: return the index of the non-null element in arrayOfStrings that has the 
     * largest number of characters that are vowels.
     * If there is a tie return the index closest to zero. 
     * The empty String, "", has zero vowels.
     * It is possible for the maximum number of vowels to be 0.<br>
     * @param arrayOfStrings the array to check
     * @return the index of the non-null element in arrayOfStrings that has 
     * the largest number of vowels.
     */
    public static int mostVowels(String[] arrayOfStrings) {
        // check preconditions
        if (arrayOfStrings == null || arrayOfStrings.length == 0 || !atLeastOneNonNull(arrayOfStrings)) { 
            throw new IllegalArgumentException("Violation of precondition: " +
                    "mostVowels. parameter may not equal null and must contain " +
                    "at least one none null value.");
        }

        String vowels = "aeiou";
        // last index of array since the loop starts from the end of array
        int indexOfMostVowels = arrayOfStrings.length-1;
        int countOfVowelsInMostVowels = 0;

        // go through all of the strings int the array
        // Start from end of array so you can settle tie with string 
        // closest to index 0
        for(int i = arrayOfStrings.length - 1; i >=0; i--){

            // make sure the string isnt null
            if(arrayOfStrings[i] != null){

                // turn the string into an all lowercase array of strings 
                // so that you can check if each character is a vowel
                String[]str = arrayOfStrings[i].toLowerCase().split("");
                int countOfVowels = 0;

                // count vowels in currently selected string
                for(String x: str){

                    // must ignore empty string and see if the character 
                    // is vowel before counting
                    if(!x.equals("") && vowels.contains(x)){
                        countOfVowels++;
                    }

                }

                // if this string has more vowels than previous
                // then set it's index as the indexOfMostVowels
                // and replace highest vowel count to current count
                if(countOfVowels >= countOfVowelsInMostVowels){
                    indexOfMostVowels = i;
                    countOfVowelsInMostVowels = countOfVowels;
                }

            }


        }

        return indexOfMostVowels;
    }



    /**
     * Perform an experiment simulating the birthday problem.
     * Pick random birthdays for the given number of people. 
     * Return the number of pairs of people that share the
     * same birthday.<br>
     * @param numPeople The number of people in the experiment.
     * This value must be > 0
     * @param numDaysInYear The number of days in the year for this experiement.
     * This value must be > 0
     * @return The number of pairs of people that share a birthday 
     * after running the simulation.
     */
    public static int sharedBirthdays(int numPeople, int numDaysInYear) {
        // check preconditions
        if (numPeople <= 0 || numDaysInYear <= 0) {
            throw new IllegalArgumentException("Violation of precondition: " +
                    "sharedBirthdays. both parameters must be greater than 0. " +
                    "numPeople: " + numPeople + 
                    ", numDaysInYear: " + numDaysInYear);
        }

        int[] birthdays = new int[numPeople];
        int numberOfPairs = 0;

        // generate random birthdays 
        for(int i = 0; i<numPeople; i++){
            Random r = new Random();
            birthdays[i] = r.nextInt(numDaysInYear);

        }

        // go through list of birthdays
        for(int i = 0; i < birthdays.length; i++){

            // compare to every birthday except itself and the ones before it
            // because the ones before it have already been compared
            for(int x = i+1; x < birthdays.length; x++){
                if(birthdays[i] == birthdays[x]){
                    numberOfPairs++;
                }
            }

        }

        return numberOfPairs; 
    }



    /**
     * Determine if the chess board represented by board is a safe set up.
     * <p>pre: board != null, board.length > 0, board is a square matrix.
     * (In other words all rows in board have board.length columns.),
     * all elements of board == 'q' or '.'. 'q's represent queens, '.'s
     * represent open spaces.<br>
     * <p>post: return true if the configuration of board is safe,
     * that is no queen can attack any other queen on the board.
     * false otherwise.
     * the parameter <tt>board</tt> is not altered as a result of 
     * this method.<br>
     * @param board the chessboard
     * @return true if the configuration of board is safe,
     * that is no queen can attack any other queen on the board.
     * false otherwise.
     */
    public static boolean queensAreSafe(char[][] board) {
        char[] validChars = {'q', '.'};
        // check preconditions
        if (board == null || board.length == 0 || !isSquare(board) 
                || !onlyContains(board, validChars)) {
            throw new IllegalArgumentException("Violation of precondition: " +
                    "queensAreSafe. The board may not be null, must be square, " +
                    "and may only contain 'q's and '.'s");        
        }

        char queen = validChars[0];  // 'q' stands for queen on the board
        for(int row = 0; row < board.length; row++){

            for(int column = 0; column < board.length; column++){
                // find queen in matrix
                if(board[row][column] == queen){
                    
                    for(int i = 0; i < board.length; i++){
                        // check horizontal for queen
                        if(i != column && board[row][i] == queen){
                            return false;
                        }

                        // check vertical for queen
                        if(i != row && board[i][column] == queen){

                            return false;
                        }

                        // check diagonal 1(\) for queen
                        int columnDiagonal1 = column - (row - i);
                        if(columnDiagonal1 >= 0 && columnDiagonal1 < board.length){
                            if(i != row && board[i][columnDiagonal1] == queen){
                                return false;
                            }
                        }

                        // check diagonal 2(/) for queen
                        int columnDiagonal2 = column + (row - i);
                        if(columnDiagonal2 < board.length && columnDiagonal2 >= 0){
                            if(i != row && board[i][columnDiagonal2] == queen){
                                return false;
                            }
                        }
                        
                    }


                }
            }
        }

        // passed all directional tests for all queens on the board
        // so the board is safe
        return true; 
    }

    /**
     * Given a 2D array and a starting point (row,column) it returns 
     * the value of the most valuable contiguous sub rectangle from 
     * that starting point
     * 
     * @param city The 2D array of ints representing the value of
     * each block in a portion of a city.
     * @param row the row of the starting point in the city array
     * @param column the column of the starting point in the city array
     * @return the value of the most valuable contiguous sub rectangle
     * in the city array from the given starting point with row and column
     */
    private static int getMostValueFromStartingPoint(int[][]city, int row, int column){
        int highestValue = city[row][column];

        // runs through all rows from starting row and onwards
        for(int r = row; r < city.length; r++){
            // keeps count of value of current rectangle
            int sum = 0;

            // runs through all columns from starting column and onwards
            for(int c = column; c < city[r].length; c++){
                // adds values from previous columns
                for(int currentRow = r; currentRow >= row; currentRow--){
                    sum += city[currentRow][c];
                }   
                // if current rectangle is larger than previously 
                // largest rectangle then replace 
                // highest value with new rectangle value
                if(sum > highestValue){
                    highestValue = sum;
                }           
                
            }

        }

        return highestValue;
    }

    /**
     * Given a 2D array of ints return the value of the
     * most valuable contiguous sub rectangle in the 2D array.
     * The sub rectangle must be at least 1 by 1. 
     * <p>pre: <tt>mat != null, mat.length > 0, mat[0].length > 0,
     * mat</tt> is a rectangular matrix.
     * <p>post: return the value of the most valuable contiguous sub rectangle
     * in <tt>city</tt>.<br>
     * @param city The 2D array of ints representing the value of
     * each block in a portion of a city.
     * @return return the value of the most valuable contiguous sub rectangle
     * in <tt>city</tt>.
     */
    public static int getValueOfMostValuablePlot(int[][] city) {
        // check preconditions
        if (city == null || city.length == 0 || city[0].length == 0 
                || !isRectangular(city) ) {
            throw new IllegalArgumentException("Violation of precondition: " +
                    "getValueOfMostValuablePlot. The parameter may not be null," +
                    " must value at least one row and at least" +
                    " one column, and must be rectangular."); 
        }        

        int highestValue = city[0][0];

        for(int row = 0; row<city.length; row++){

            for(int column = 0; column < city[row].length; column++){
                // finds rectangle with highest value from this point
                int maxValFromThisPoint = 
                        getMostValueFromStartingPoint(city, row, column);
                // if this new highest value exceeds previous highest value, 
                // then it replaces it
                if(maxValFromThisPoint > highestValue){
                    highestValue = maxValFromThisPoint;
                }
            }

        }

        // returns highest possible value out of the 2D array 
        // out of all starting points
        return highestValue; 
    }


    // !!!!! ***** !!!!! ***** !!!!! ****** !!!!! ****** !!!!! ****** !!!!!!
    // CS314 STUDENTS: Put your birthday problem experiment code here:

    /**
     * perform birthday experiment as many times as you want 
     * works with sharedBirthdays method
     * returns average number of pairs that occur
     * 
     * @param numOfExperiments the number of experiments that you want to run
     * @param numPeople the number of people to be used in the birthday problem
     * @param daysPerYear the number of days in a year to be 
     * used in the birthday problem
     * @return the average number of pairs out of all of the experiments
     */
    public static double averageNumberOfPairsExperiment(int numOfExperiments, int numPeople, int daysPerYear){
        // keeps count of the sum of all the results
        double totalSumOfPairs = 0;

        // performs expriments and adds results to totalSumOfPairs
        for(int i = 0; i < numOfExperiments; i++){
            totalSumOfPairs += sharedBirthdays(numPeople, daysPerYear);
        }

        // returns the average number of pairs
        return totalSumOfPairs/numOfExperiments;
    }

    /**
     * performs birthday experiment and returns the number of experiments
     * that have at least 1 shared birthday
     * 
     * @param numOfExperiments the number of experiments you want to run
     * @param numPeople the number of people to be used in the birthday problem
     * @param daysInYear the number of days in a year to be used
     * in the birthday problem
     * @return the number of experiments that had at least one pair
     */
    public static int countOfExperimentsWithAPair(int numOfExperiments, int numPeople, int daysInYear){
        // keeps count of experiments that have atleast one pair
        int countOfExperiments = 0;

        // runs experiments
        for(int i = 0; i < numOfExperiments; i++){
            // adds to counter if experiment has a pair
            if(sharedBirthdays(numPeople, daysInYear) >= 1){
                countOfExperiments++;
            }
        }

        return countOfExperiments;

    }

    /**
     * Performs the second experiment for the birthday problem and draws the table
     * 
     * @param minRange the minimum number of people (inclusive)
     * @param maxRange the maximum number of people (inclusive)
     */
    public static void runBirthdayExperiment2(int minRange, int maxRange){
        
        for(int i = minRange; i <= maxRange; i++){
            int count = countOfExperimentsWithAPair(50000, i, 365);
            double percentage = (count/50000.)*100;
            System.out.print("Num people: "+i+", number of experiments with one or more shared birthday: "+count+", percentage: ");
            System.out.printf("%.2f",percentage);
            System.out.println();
        }
    }

    /* 
     * pre: arrayOfStrings != null
     * post: return true if at least one element in arrayOfStrings is 
     * not null, otherwise return false. 
     */
    private static boolean atLeastOneNonNull(String[] arrayOfStrings) {
        // check precondition
        if (arrayOfStrings == null) {
            throw new IllegalArgumentException("Violation of precondition: " +
                    "atLeastOneNonNull. parameter may not equal null.");
        }
        boolean foundNonNull = false;
        int i = 0;
        while( !foundNonNull && i < arrayOfStrings.length ) {
            foundNonNull = arrayOfStrings[i] != null;
            i++;
        }
        return foundNonNull;
    }


    /* 
     * pre: mat != null
     * post: return true if mat is a square matrix, false otherwise
     */
    private static boolean isSquare(char[][] mat) {
        if (mat == null) {
            throw new IllegalArgumentException("Violation of precondition: " +
                    "isSquare. Parameter may not be null.");
        }
        final int numRows = mat.length;
        int row = 0;
        boolean isSquare = true;
        while (isSquare && row < numRows) {
            isSquare = ( mat[row] != null) && (mat[row].length == numRows);
            row++;
        }
        return isSquare;
    }


    /* 
     * pre: mat != null, valid != null
     * post: return true if all elements in mat are one of the 
     * characters in valid
     */
    private static boolean onlyContains(char[][] mat, char[] valid) {
        // check preconditions
        if (mat == null || valid == null) {
            throw new IllegalArgumentException("Violation of precondition: " +
                    "onlyContains. Parameters may not be null.");
        }
        String validChars = new String(valid);
        int row = 0;
        boolean onlyContainsValidChars = true;
        while (onlyContainsValidChars && row < mat.length) {
            int col = 0;
            while(onlyContainsValidChars && col < mat[row].length) {
                int indexOfChar = validChars.indexOf(mat[row][col]);
                onlyContainsValidChars = indexOfChar != -1;
                col++;
            }
            row++;
        }
        return onlyContainsValidChars;
    }


    /*
     * pre: mat != null, mat.length > 0
     * post: return true if mat is rectangular
     */
    private static boolean isRectangular(int[][] mat) {
        // check preconditions
        if (mat == null || mat.length == 0) {
            throw new IllegalArgumentException("Violation of precondition: " +
                    "isRectangular. Parameter may not be null and must contain" +
                    " at least one row.");
        }
        boolean correct = mat[0] != null;
        int row = 0;
        while(correct && row < mat.length) {
            correct = (mat[row] != null) 
                    && (mat[row].length == mat[0].length);
            row++;
        }
        return correct;
    }

    // make constructor private so no instances of CodeCamp can not be created
    private CodeCamp() {

    }
}